#+TITLE:  Perl 6, the musical


#+latex_compiler: xelatex
#+LaTeX_CLASS: book
#+latex_header: \usepackage{libertine}
#+latex_header: \usepackage{unicode-math}
#+latex_header: \setmonofont{DejaVu Sans Mono}

* Introduction
This book is about learning programming using a promising, and almost
completely new, language: Perl 6. But it is only Perl 6 specific in
a minority of the content. Most chapters that deal with Perl 6 could
be rewritten using any other language, preferably a new, cool language
such as Go or Rust. I, or someone, might do it some day. But for the
time being, let us be content with Perl 6. Which is also new and cool.

* ℵ - Principles
   :PROPERTIES:
   :UNNUMBERED: T
   :END:

A few principles that inspire this (book|booklet|manual|you name it),
originally conceived to help non-programmers get into Perl 6

** Learning should be fun and engaging: learn by doing.

The best way to make people actually learn something is by putting
inmediately to practice whatever is being learned, be it programming
or weaving. So you should have your computer handy and learn the tools
as soon as possible to put things to practice. 

** You are the master of your learning process, and tools, and outcome. 
You should learn at your own step, stopping whenever you want and
actually taking lessons when you feel like doing it. Engagement will
ensue. 

** Learning never stops.

If you learn only during the short period where /class/ is taking
place, you will not learn too much. You have to digest and assimilate
and come up with new ideas. Some of them will be relevant to whatever
you are learning, some of them will be revealed as relevant later on,
some of them will be simply discarded. But you can leverage whatever
experience you have to enhance what you are learning, even more so if
it is a programming language. 

** Learning is a two-way process. There is no professor, no student: learning happens ideally in a community. 

This is kinda /zen/, but then the whole thing stinks of a holistic
experience, where you learn about life by learning about programming
dha back. That also means that learning comes from every direction at
once: the other students, maybe whoever is preparing objectives and
material for the day, but that person will also learn new things about
him or herself and about whatever is teaching, because the best way to
learn is to prepare something to be taught to others. 

Besides, there is no learning outside self-learning. But maybe that is
a completely different story. 

* б - Motivation
   :PROPERTIES:
   :UNNUMBERED: T
   :END:

This is (mostly) a book on Perl 6. But my initial intention was not to
show how to program in Perl 6. Here are a few of my motivations, which
might be also your own for actually reading and following this book. 

** Teaching programming to (almost) non-programmers.

Most programming books seem to be written eigther for people that already know
how to program or for people that barely knows how to press
keys. There must be a middle ground, and I try to tread it with this
book. If know how to use a computer, you should be ready to go the
whole nine yards and learn to create things in Perl 6 by the end of
the book, if that eventually happens. 

** Contemplate the possibilities of Perl 6 as a beginner's language.
There seems to be a consensus that there is such a thing as a /good
language for beginners/, and that that language is Python. Well, maybe
it is, but why would any other languages, Rust, JavaScript or even C++
be worse? Asking about the best programming language for beginners is
like asking about the best foreign language for beginners. Evidently,
the best is the language you want to learn. If you want to learn
Chinese, you do not learn first... whatever language is closer to
yours and easier than Chinese (maybe Vietnamese? No idea, really, I
got trapped in the metaphor). You learn Chinese and are done with it. 

Point is, when you want to learn to program you usually have some kind
of job or task in mind. The best language to learn programming is a
language that can do that job. And Perl 6 can be that language.

** Show the beauty and craft of programming.

"Good technically, but lacks passion" is probably one of the worst
things that can be said about a musician or even a footballer. Should
be the case also for programmers. Those focused on getting the job
done well /technically/ will probably lack the will, or the stamina,
to learn new things or to completely switch the language or the
toolbelt you are using. Along with programming, you have to make
students learn the craft and also the beauty of a minimalistic, fast
and beautiful program. 

** Use project-based learning throughout and flipped-learning techniques.


Which boils down to "talk little, do a lot". No slides, no heavyweight
course materials, just a screen with examples, and make people perform
short tasks and reproduce what is being said by themselves. Hands have
better memory than eyes. Use that. 

In this book, in most cases activities will have a particular purpose
and will follow or flow from one chapter, or asides, to the next
ones, so that you will end up building one, or several, scripts
or programs or even notes that will be useful by themselves. 

* α - Design thinking
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

Source https://dschool.stanford.edu/sandbox/groups/designresources/wiki/36873/attachments/74b3d/ModeGuideBOOTCAMP2010L.pdf?sessionID=e62aa8294d323f1b1540d3ee21e961cf7d1bce38

** Empathization

Find users, find out about them, care about them, know their stories. Maybe you are the user, maybe it's someone close to you.

** Definition

Define the challenge, what you want to do, express the problem. This
phase can be merged with the next one, since it is difficult to define
the problem without recourse about how you are going to solve the
problem itself. 

** Ideate

Try to find out the solution to the problems your users have. 


In this phase you are supposed to produce ideas to solve the
problem. There will be no restriction other than whatever is required
by your target. You might want to create problems that imply certain
devices and not others, or solutions that cost no more than a certain
amount of money. 

** Prototype

We will transition to actually doing something, incrementally. And
this is a phase, together with the following one, that is actually in
the engineering realm, so we are in familiar ground here. 

** Test

If you are the user yourself, try it out. See if it is useful as
intended. Actually, test-driven design dictates that you cannot
actually prototype without testing in advance. So testing and
prototyping go hand in hand. 

* The tools of the trade 

This part will not be leading away from the design thinking mindset,
but actually will be getting into the last phases of it. Whatever idea
you had in mind will have to be kept stashed to go back to it whenever
you need it. In fact, we are entering the phase called /prototyping/,
or seen in another way, you are trying to solve a problem for a target
audience, yourself, by choosing the right tools. 

In this phase you will find that there's no perfect tool for doing
everything.

#+BEGIN_QUOTE
Although the combination Linux + Emacs comes pretty close 
#+END_QUOTE

Let's start with the operating system. That would be Linux. Whew, that
was short. But let's proceed to that thing that actually allows users to run programs, the shell. 

** Shells 

Then, the command line interpreter, also called /shell/. This might seem like a given, but
in fact different command line interpreters have different
capabilities. In fact, even the [[https://www.gnu.org/software/bash/][humble bash]] has
interesting capabilities you can use. Main thing you want to tap is
the possibility of displaying interesting information in the command
line, such as the directory you are working on or, later on, the
branch of the repository you are in. And, in that sense, 
there are quite a few choices here, but the main
thing about them is the possibility of /theming/ them, that is, making
a configuration that allows, mostly, find the information we mention
above by just selecting a /theme/. In that sense [[http://zsh.sourceforge.net/][zsh]] and [[https://fishshell.com/][fish]] are very
strong contenders. Install them the usual way, and then select a theme
that goes easily with your programming habits;
[[https://github.com/robbyrussell/oh-my-zsh][Oh My Zsh]] or [[https://github.com/Bash-it/bash-it][bash-it]] are good places to start. 

Play a bit with the themes or options until you find one with all the
colors and contrast you want. And then come back here for the...

** Editors. 

The choice of an editor goes beyond mere utility to become an
indentity, a side to stand when the flame war starts. As above, the
motto is always /suit yourself/, but since we are in the realm of
Perl6, I would propose [[http://atom.io][Atom]] as the editor to use. It is a modern
editor, it has got a good and evolving support for Perl 6, and it is
free software.

Not that the traditional Emacs and Vi/Vim are not good choices too. At
least Emacs, but Atom is easier to use and is improving in speed and
support by the minute. Besides, it has got everything it takes for
professional editor: syntax highlighting, being able to do some checks
from the editor itself, and allow running and debugging. It has got
all that, so that will be it. 

To go with the editor, you need some relatively fast way of inputting
some characters such as ሁ or Щ. I have used the application "Character
Map" that comes with Ubuntu; after finding a character by the name of
the alphabet, you can go to Character Details and copy/paste it to
wherever you want it used. You can also click twice and the character
will appear in the "Text to copy" slot. 

[[./img/charmap.png]]

Of course, something would be missing here if I did not mention `vim`. Here you go, a mention.

** Shells within editors

Editors are cool because they allow to work with all kind of symbols
that are not exactly text, or that  cannot be produced with a
combination of key strokes. Emacs is great at that, and it can access
the whole set of symbols that are out there by name using a
combination of keys. And it can also run a shell inside, your favorite
shell, in fact. So enter =emacs= and then type =Escape key + x= and
then, when a prompt appears in the lower line, =shell= and you will
have your shell running /inside/ Emacs, with access to all kind of
goodies, like saving sessions as files, searching using all Emacs
facilities, and all kind of symbols that can be used in it. 

* ß - We need to talk about Unicode
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

This does not belong to the language proper, but it is still something
that has to be mentioned. Languages are used to write applications,
and these can use any language in the world. [[https://unicode-table.com/es/][Unicode]] is the way to use
any alphabet, and some [[http://www.omniglot.com/conscripts/natlangs.htm][neographies]] and emoticons, in our
programs. Luckily enough, Perl6 packs one of the best supports for
this; unluckily, Unicode is complicated /per se/, so we will have to
learn a bit of linguistics to understand how we, later on, are going
to handle this, which we will even if we write only for ourselves.

First important concept is the /codepoint/. A code point is pretty
much equivalent to a letter, although it can be a symbol or also a
formatting instruction such as Tab or Newline. Every code point
corresponds to a numeric combination, which is usually expressed in
hexadecimal; for instance, =0x2017= corresponds to the character =‗=,
part of a table-drawing set. Every character also has a series of
attributes, including the category; this character belongs to the =Po=
[[https://en.wikipedia.org/wiki/Unicode_character_property#General_Category][category]],
meaning that it is /Punctuation, other/. The [[http://userguide.icu-project.org/strings/properties][properties]] include a
series of attributes such as the fact that they are numeric or can do
things like folding to a particular case or be joined to the next
character, or even if the direction they are written in. 

Characters are written as [[http://mathias.gaunard.com/unicode/doc/html/unicode/introduction_to_unicode.html#unicode.introduction_to_unicode.grapheme_clusters][graphemes]], and usually a code point
corresponds to a single written grapheme; however, in some cases code
points group to form a /grapheme cluster/, which is a set of code
points that constitute a grapheme; the most common example is letters
with marks such as á, but more complicated expressions might be
thought of. Or not, depending on your imagination. 

You write graphemes and grapheme clusters as /glyphs/, or letters. And
these are typeset, in a particular environment, using /fonts/. A font
is a set of mathematical formulae, yes, there is math involved, that
allows to render a particular letter in many different sizes and forms
such as italics or boldface. The fact that they are a formula, and
that you have to design formulae for every single glyph, means that
not all glyphs might be available in all fonts. Some fonts will have
all, or most of them, some of them not. And that, in turn, means that
some Etruscan letter such as this one 𐌚 that renders beautifully in
your editor might show up as an x-marked rectanble or question mark
somewhere else, a console or a word processor. In fact, depending on
how you are reading this, you might not see the glyph I'm referring to
at all. 

Your take away message here is that you need to know how to use
Unicode in whatever program you use, and that some particular
structures of the program, like operators or names, will use graphemes
with particular properties, probably something alphabetic-like. Also
that unicode is complicated, but that you should better learn about it
as soon as possible, as in now. 
* The expressions

The first thing you need to know about a language, any language, is
how to compute things. Compute in the more general sense: combine
things to give other things. This, in general, is called expression,
which, also in general, is a bunch of symbols linked by *operators*. 

Generally, modern computer languages are able to work with many
different kind of symbols, and Perl6 is no exception. Let's start with
that.

** REPLs and how to use them as glorified calculators

A
[[https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop][REPL]]
is a Read-Eval-Print loop. it is a program included with most
interpreted languages, that presents a command-line prompt and into
which you can type expressions, and, later on, full statements. But,
for the time being, let's type


#+BEGIN_EXAMPLE bash
perl6
#+END_EXAMPLE

And we will be into a perl6 REPL into which you can type Perl6 stuff.

Let's try the simplest thing:


#+BEGIN_EXAMPLE perl6
To exit type 'exit' or '^D'
> sin(π/2)
#+END_EXAMPLE

You will have to find a way to type that π, by copy/pasting it from
some website or google or right this. It will return the sine of π/2,
which, as you know, is 1. 

And this is cool, because only some languages are able to handle this
kind of expressions, and, even more, to use it correctly in math. But
you can do even more:


#+BEGIN_EXAMPLE perl6
sin(π/2) +1
#+END_EXAMPLE

You can do that by copying/pasting, or else install =Linenoise=, a
command line that allows you to go back to previous command by typing
arrow-up. Do it with


#+BEGIN_EXAMPLE bash
zef install Linenoise
#+END_EXAMPLE

You can use the usual arithmetic operators =+,-,*,/= but Perl6 adds
two typographic operators, ÷ and × (these ones are produced in the
Spanish keyboard with May+AltGr+ comma or period), like


#+BEGIN_EXAMPLE perl6
sin(π/3) × sin(π/3) + cos(π/3) × cos(π/3)
#+END_EXAMPLE

Or, even better


#+BEGIN_EXAMPLE perl6
sin(π/3)² + cos(π/3)²
#+END_EXAMPLE

One of the objectives of Perl6 is to use the whole range of characters
that Unicode, if not modern keyboards, offer. This simplifies
expressions and makes them more readable. 

You will not find all numbers in superscript mode. If you want to
raise a number to the /x/th power, use =**=.
#+BEGIN_EXAMPLE perl6
3**25
#+END_EXAMPLE

Arithmetic only takes you so far in programming. We will learn how to
deal, and operate, with all kinds of data in this glorified
calculator. 

** Now that we mention Unicode

Unicode is the way to express all alphabets in the world, and then
some things that are not really alphabets. It uses up to around sixty
thousand symbols, and allows us to write, using modern operating
systems, editors and languages, anything that would have to be
expressed in living or dead languages, and even some
emoticons. Unicode is evolving constantly, and for the people means
that they will be able to use characters that are usual in their own
language, and also some usual in mathematical expressions. 

Since not all languages, editors, operating systems or even keyboards
are *modern* in that sense, some impedance should be expected. But
Perl 6 will not get in your way, allowing you to use them just they
way they should, so if you want to raise something to the second power
you will not have to, although you can, write x**2 but simply x².

** It's not only numbers

All the expressions written above are numbers. 


#+BEGIN_EXAMPLE perl6
(sin(π/3)² + cos(π/3)²).WHAT
#+END_EXAMPLE

is going to return =(Num)=, indicating that it is simply a Number,
actually a real number. This =.WHAT=, together with surrounding the
expression via parentheses meaning grouping, is a way to apply a
/property/ or to call a /method/ on that object. In Perl6, everythin
is an object, and objects have a class, and you want to call methods
that correspond to objects of that class, append a dot and use the
method, possibly with some arguments like =WHAT(is, "the",
$what)=. Let's not worry about that for the time being, or about
classes themselves. Just with the fact that every expression is an
object, and those objects belong to a class; every class in Perl6
/descends/ from the ur-class called μ or =Mu=. And among the
[[https://docs.perl6.org/type/Mu][properties of Mu]] is that you can call this =WHAT=. Any other class
descends from this one, so /you can call =.WHAT= on any object of any
class/. That is the take-home message, even if you might not know, so
far, what is an object, or a class. Second take home message:
/different objects also have different classes/. 

Since both /objects/ at the sides of the =+= are Nums, you
can add or substract them or do any other arithmetic operation, but you cannot do 


#+BEGIN_EXAMPLE perl6
sin(π/3)² + cos(π/3)² + " is 1"
#+END_EXAMPLE

will yield this error
#+CAPTION: Errorred expression in the REPL
#+NAME:   fig:chap2-expression
[[./img/expression-error.png]]

And the reason for that can be found out by typing:
#+BEGIN_EXAMPLE perl6
" is 1".WHAT
#+END_EXAMPLE

Which, whatever it is, is not a =Num=, so it cannot be added. 
That shows that there are more types of data you can use and work with
from the REPL. In fact, there are a lot. In general, you cannot mix
and match and, also in general, every one has got its own operators
you can work with. You can mix fractions with integer numbers, for
instance: 

#+BEGIN_EXAMPLE perl6
 ⅓+4/3
#+END_EXAMPLE

And 

#+BEGIN_EXAMPLE perl6
(⅓+4/3).WHAT
#+END_EXAMPLE

will return =(Rat)=, a Rational, same as =⅓+4=. In fact, most
[[http://blogs.perl.org/users/ovid/2015/02/a-little-thing-to-love-about-perl-6-and-cobol.html][floating point numbers in Perl 6 will be represented as rational]],
unless we explicitly tell the interpreter to deal with them as
floating point, that is real, numbers, which, BTW, cannot be something
else that fractional numbers since they use a finite representation in
computers. Mostly.

However, in some cases you can try and mix different things using an
operator. Operator "~" concatenates stuff, that is, joins things that
look like words and letters, for instance

#+BEGIN_EXAMPLE perl6
6 ~ "6"
#+END_EXAMPLE

will return =66=, and anything you put there will be concatenated. =~=
is an operator that is not picky about what it has got in both ends. 

You cannot add strings together, because that is what they are, but curiously enough, you can multiply them:

#+BEGIN_EXAMPLE perl6
"1" ~ "\n" ~ "2" x 2 ~ "\n" ~ "3" x 3 ~ "\n" ~ "2" x 2 ~ "\n" ~ "1"
#+END_EXAMPLE

This being a rather nice and utterly useless example on the operator
=x=, which /multiplies/ or rather /replicates/ whatever character of
string it is related to. Introduced together with =\n", the carriage
return, so that if forms a nice pile of stuff. 

Which is shorter and better in this example

#+BEGIN_EXAMPLE perl6
for <1 2 3 2 1>  { say $_ x $_ }
#+END_EXAMPLE

but that's something we will see later on, when we talk about loops
and all that's nice and beautiful about it. 

** Lists of things are also game.

Numbers and words are simple things. But you can string them together
in something more complex. You can have sets of them, or lists of
them, or combine them as sets of lists of sets of whatever. Perl 6 is
great because you do not need to make all things in a complex
structure be of the same type. You can create a list with the less than
and more than sign, this way:

#+BEGIN_EXAMPLE perl6
<a b 7 ⅓ π²>
#+END_EXAMPLE

And with lists, you can do things like sorting:

#+BEGIN_EXAMPLE perl6
sort <a b 7 ⅓ π²>
#+END_EXAMPLE

or combine lists to create a new one using the =X= operator, called
*cross product* 

#+BEGIN_EXAMPLE perl6
<a b 7 ⅓ π²> X < → ← >
#+END_EXAMPLE

You can also combine in some other ways, adding one list to another. 

#+BEGIN_EXAMPLE perl6
<a b 7 ⅓ π²> , < → ← >
#+END_EXAMPLE

The simple /comma/ operator is going to create a new list with two elements, each one of which is
a list. You can *flatten* it:

#+BEGIN_EXAMPLE perl6
flat <a b 7 ⅓ π²> , < → ← >
#+END_EXAMPLE

You can already do interesting things with these lists (or arrays, or
vectors, stuff in a row, whatever). For instance, you want to pick one
element randomly, 
#+BEGIN_EXAMPLE perl6
 (flat <a b 7 ⅓ π²> , < → ← >).pick
#+END_EXAMPLE
will return, every time you run it, a different element. You can do
that as many times as you want, but it is much easier to use =roll= to
do it many times for you.
#+BEGIN_EXAMPLE perl6
< → ← >.roll(6)
#+END_EXAMPLE
will return a whole quiver of arrows.

Maybe you want a single element of the array:
#+BEGIN_EXAMPLE perl6
 < → ← >.roll(6)[3]
#+END_EXAMPLE
This will return the 4th element, taking into account that all arrays
start with 0. Otherwise known as a random arrow. Or you might want to
extract a range
#+BEGIN_EXAMPLE perl6
(flat <a b 7 ⅓ π²> , < → ← >)[3..6]
#+END_EXAMPLE
uses the /range/ operator =..= (that is, two points), which generates
a contiguous sequence of elements. Otherwise known as, well,
range. But these ranges also behave as arrays:
#+BEGIN_EXAMPLE perl6
(0..10)[3..6]
#+END_EXAMPLE perl6
although they are not exactly the same:
#+BEGIN_EXAMPLE perl6
(0..10).WHAT
#+END_EXAMPLE perl6
will, effectively, return =(Range)=. 

This is just the start of complex structures with Perl. More to come
in the next chapters. 

* γ - Thinking like computers do
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
  

You probably know, or at least have made an educated guess, that computers are unlike humans. But since
expressions are entered in pretty much the same way you would use
somewhere else, it's no big deal. However, once you want to
deconstruct what actually needs to be done to make a computer do
whatever you want it to do, you have to start to think like a
computer, in what is known as computational thinking. It is kind of a
game of "Simon says". You have to precede every instruction you give a
computer by something that indicates you want it to do precisely that,
and then you have to say very precisely what it needs to do.

But there is more to that, the fact that you also need to indicate the
/sequence/ of actions you want the computer to do by indicating that
in your program. When you work with the REPL, as we have done above,
the sequence is quite clear: you say something, press Enter, the
computer thinks for a while or what looks like nothing, you have the
response. However, when the program gets a bit more complicated, you
also have to think, in a particular point in time, where the computer
might be and what that implies regarding values or results you need to
proceed. 

Which is why we talk about
[[https://en.wikipedia.org/wiki/Computational_thinking][computational thinking]] as a series of techniques for solving problems
using computers, including all the steps you need to take to identify
the problem, put it in a way that can be understood and processed by a
computer, and then express every step as instructions in program that
will, eventually, solve the problem. 

We will get back to this later on, but for the time being there are a
couple of techniques you will need to understand. First is /pattern
recognition/, which means finding what several different pieces of
information have in common and, in turn, what to do to solve a problem
in a case given that you know how to solve it in another case which
follows the same pattern. When you find something that has a regular
increasing or arithmetic pattern, for instance, you will discover that
you can use lists or sequences to solve it, and apply whatever you
know already on how to deal with sequences. 

The second technique we should focus on right now is /problem
decomposition/, how to break down a problem in different parts that
can, more easily, solved. For instance, you want to find what would be
the number a sequence will reach if left to grow until infinity; first
you will have to solve the problem of representing the sequence, which
might not be inmediate, and then how to apply known techniques of
limit finding, such as
[[http://tutorial.math.lamar.edu/Classes/CalcI/LimitsProperties.aspx#Limit_Props][finding the function that represents the sequence]] and then applying
what is known about function limits to that sequence. 

Every part of a problem will eventually become an instruction or
group of instructions called usually /subroutines/ or /functions/. But
for the time being, it is enough to know that breaking down a problem
in parts you already know how to solve is the key for solving problems
of any size. 

* To infinity and beyond

If you know in advance every single term of a list, writing them down
as above is the way to handle them. However, you might know a few
terms of the lists, or how they are generated, and that is that. Let
us see how to deal with them in Perl 6

** Working with ranges and sequences

For long lists, you might want to use only the first and last term 

#+BEGIN_EXAMPLE perl6
1...222
#+END_EXAMPLE

via the *yada, yada, yada* operator, or, even better,

#+BEGIN_EXAMPLE perl6
1 … 333
#+END_EXAMPLE

But the coolest thing with lists is the stuff you can do to all of
them at the same time:

#+BEGIN_EXAMPLE perl6
[+] 1 … 333
#+END_EXAMPLE

will add everything together. Any operator you put inside brackets
will be applied to all in turn. Try =[*] 1 … 333=, for instance.

But the coolness factor can be increased:
#+BEGIN_EXAMPLE perl6
[+] 1,3 … 333
#+END_EXAMPLE

and even
#+BEGIN_EXAMPLE perl6
[+] 1,3,9 … 333
#+END_EXAMPLE

The =[]= is called a /reduce/ operation. If you have heard some big
data buzz, you have probably heard about an operation called
*map/reduce*. Well, this is the /reduce/ part. And it is so easy to do
with Perl6.

Because Perl6 is able to deal with arithmetic and geometric progressions out
of the box. And even infinite ones:

#+BEGIN_EXAMPLE perl6
1,3,9 … ∞
#+END_EXAMPLE

You can obtain the 100th term using

#+BEGIN_EXAMPLE perl6
(1,3,9 … ∞)[100]
#+END_EXAMPLE

or, why not, the terms from 1000 to 1100

#+BEGIN_EXAMPLE perl6
(1,3,9 … ∞)[1000…1100]
#+END_EXAMPLE

which will return a pile of numbers, separated by spaces. It is quite
usual to start from 0 and go to a particular number. The /caret/ = ^ =
is used to indicate /0 to/ the number that follows it

#+BEGIN_EXAMPLE perl6
(0,5,10 … ∞)[^25]
#+END_EXAMPLE

will list the 25 first elements of the list of multiples of 5. 

 Besides, at the same time, we have seen how to deal with a single term in a
list, and how to work with a series of terms. You can use infinite
syntax to generate also finite lists if you do not want to compute in
advance the precise terms of it. For example, above you will be
working on the 1000th term and on of an infinite list, without working
out if it is exactly 3000 or some such. You can check out
[[https://perl6advent.wordpress.com/2010/12/04/the-sequence-operator/][this Advent calendar entry for a few samples of Perl6 coolness too]].

** Operating on lists
Lists are perfectly good subjects for this calculator on steroids we
have in the REPL. Whatever combination you think about, it is probably
possible to do it on lists; some of them will work also on infinite
lists, but most probably not. We have already seen =[+]= work on a
list of numbers. Any sensible operation like =[*]= will also work. But
this will also yield a result:
#+BEGIN_EXAMPLE perl6
[~] 'a'..'z'
#+END_EXAMPLE
collating together all elements in the alphabet. Preceding it with
=\=. which you can think of as an accumulator, will instead create
another array whose elements are the accumulation of the operation up
to that element. Better if you try it:

#+BEGIN_EXAMPLE perl6
[\~] 'a'..'z'
#+END_EXAMPLE

This can be very useful when working on accumulative series, for
instance, what is the sequence of factorials up to 25?
#+BEGIN_EXAMPLE perl6
[\*] 1..25
#+END_EXAMPLE

This accumulator is called a /zip/ operator. We will see later on what
it actually means, for the time being it just makes operating with
series a bit easier. 

But single lists only take you so far. Previously we have seen the
comma for kind-of joining two lists. But there are multiple ways of
creating new lists by combining them. For instance, the /cross/
operator =X= will create a list of lists from two of them
#+BEGIN_EXAMPLE perl6
(1,3...10) X (2,4...10)
#+END_EXAMPLE
will combine all even and odd numbers in pairs, combining 1 with 2 to
10, then doing the same with 3... This can be useful if you want to
create a combination, but even more so if you turn =X= into a
hyper-operator by using it to precede any operation such as =*= 
#+BEGIN_EXAMPLE perl6
(1,3...10) X* (2,4...10)
#+END_EXAMPLE
will create a /flat/ list with the results of multiplying the pairs we
have generated before. This can be useful for complicated arithmetics,
but sometimes we only want to pair a couple of lists to create a new
one that takes one element from each one, combining them like the
tooth of a zipper. This operation is appropriately named Zip and
represented by =Z=
#+BEGIN_EXAMPLE perl6
 (5,10...Inf)[^20] Z (4,8...Inf)[^20]
#+END_EXAMPLE
This creates a new list that zips together similar terms in the
sequence of multiples of 4 and 5. Can we multiply them to create a
sucession of multiples of 20? Maybe...
#+BEGIN_EXAMPLE perl6
 (5,10...Inf)[^20] Z* (4,8...Inf)[^20]
#+END_EXAMPLE

* δ - Working as a team
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
  

You will never walk alone when solving a problem. Even if you are
working in a side project, something you thought about yourself, you
will need an easy way to keep track of changes and also to easily
incorporate whatever suggestions or even changes somebody else might
be doing to your code. And that easy way is to [[https://git-scm.com/][use git]]. =git= is
described as a distributed source code manager, but it is much more
than that, it is a way of life. =git= organizes code in
/repositories/, pretty much corresponding to projects, but including
also artifacts such as documentation, manuals and examples. 

As a way of life, it needs much more than a single section in a
book. You will eventually learn as you go, but for the purpose of
this, let us say you have opened an account in an online Git server
such as [[http://github.com][GitHub]]. GitHub is free for public repositories, and even for a
few closed ones if you are a student. If you do not feel comfortable
with this, do not worry, you can use [[http://bitbucket.com][BitBucket]], which allows private
repositories with some limitations on the number of users and number
of repos.

Be that as it may, you will need a repository to store all the files
that you will be writing in this, maybe also your couse notes. It is
going to be fun start to create a single program, and keep changing it
over the same file; git will record changes and you will be able to
track your own progress over this file. In order to do that, create a
repository or project in any of them, and 
choose a sensible free software license, as well as Perl as a language
(closest to Perl6) and also generate a =README.md=, which is in
Markdown. 

That creates a git repository in whatever computer hosts GitHub (or
BitBucket), but git is a distributed system, and you can synchronize
your computer with the contents of the repository out there. Bring it
down with 

#+BEGIN_EXAMPLE perl6
git clone https://github.com/yourname/yourrepo
#+END_EXAMPLE

and please note I am using =https= here. You can also use the /ssh/
address and in fact you should, but for the time being let us let it
be. Remember to take down the username and password you have used,
because you will need later on.

That command will create a =yourrepo= directory hanging from wherever
you are. Change to it with =cd yourrepo= and start working there. For
instance, create a new file with =touch a_new_file=. Not everything in
the directory is /in/ the repository, you have to purposefully add to
it. 

#+BEGIN_EXAMPLE perl6
git add a_new_file
#+END_EXAMPLE

* Thinking logically

You are going to need in many cases whether something is true or
false: check if a file exists, check if a number is bigger or smaller
than another, or even check if a complicated local proposition is true
or not. In fact, everything in computers uses logic, to the point that
all information is codified using true or false values, what is called
a /bit/. There are so many layers over that that you do not need to be
much concerned about this, but you need to know about expressing logic
in programs, and specially in Perl 6, which is what we are dealing
with right now. 

** Comparing things

Let's see how Perl6 performs simple comparison operations

#+BEGIN_EXAMPLE perl6
3 > 2
#+END_EXAMPLE

will return =True=, 

#+BEGIN_EXAMPLE perl6
2 == 3
#+END_EXAMPLE

will return =False=, because 2 is not equal (==) to 3. Remember, == is
used for comparison, and the rest of the operators are quite
usual. Whenever an operations can be true or not, it will return a
=False= or =True= value, and all these comparison operations
are. Perl6 adds another /smart/ comparison

#+BEGIN_EXAMPLE perl6
2 ~~ 3
#+END_EXAMPLE

will return =False=, but

#+BEGIN_EXAMPLE perl6
2 ~~ "2"
#+END_EXAMPLE

will return =True=. The /smartness/ of the operation means that it
will be able to recognize something even across different types, as in
this case, where we are comparing a number (or =Int=) with a =Str=. It
is even smarter

#+BEGIN_EXAMPLE perl6
3 ~~ Ⅲ
#+END_EXAMPLE

because it understands, as in this case, Roman numerals. 


* ‎ε - The command line
    :PROPERTIES:
    :UNNUMBERED: t
    :END:

In the principle was the command line. That is so true. You run
scripts from the command line, and you go back to it when you are
done. But also the Linux was created with a set of command line tools
that can be integrated with your program to save you typing and
thinking and energy. There is so much you can do with it, that we will
need to know how it works, starting with organization of the disk
drive. 

The disk drive is nowadays mostly solid-state, or else it is so fast
you do not need to worry about it. Anyway it is organized like an
inverted tree, with the =root= at =/= and all branches and leaves
hanging from it. That tree would branch on /directories/ or /folders/
and the leaves hanging at the far end would be /files/. In Linux,
branching is marked by =/=, so a file /this.is.a.file/ in a folder called /jj/ which is
inside another folder called /home/ will be completely qualified by
=/home/jj/this.is.a.file=, or, sometimes, using web-style universal
resource identifier, =file://home/jj/this.is.a.file=. The characters
beyond the last period are usually called the /extension/. They are no
big deal, actually, just a part of the name, but they usually have a
conventional value for particular kind of files, like =.txt= for text
files and things like that. 

When you are working from the command line, you are always in a
particular directory, which is called the /working/ directory. You
probably have used [[https://github.com/Bash-it/bash-it][Bash it]] or something like that to show it on the
command line; if you have not, well, do it now. =cd= is used to change
this working directory, and you can use absolute names or
abbreviations like =..= for the directory that contains your current
working directory. 

We have already seen a few things the operating system can do,
including the command /shell/, or command interpreter, which includes
some orders and also fetches program for you to run, and also
editors. But there are a few more orders that will be invaluable when
using Linux as a programmer.

** Moving stuff around

=cp=, as in "copy" copies files to another directory, maybe with
another name

#+BEGIN_EXAMPLE bash
cp this.is.the.original.file ../to/this.is.a.copy
#+END_EXAMPLE

will copy the original file to a directory called =to=, and with a
different name. =..= is the upper directory. Similarly,
 
#+BEGIN_EXAMPLE bash
mv this.is.the.original.file ../to/this.is.a.copy
#+END_EXAMPLE

will /move/ or change the name of the file, that is, copy and also
remove the original file. If you just want to get rid of a file =rm
file= will do it. 

** =find= 

Used to find files by name, it is invaluable when you do not remember
exactly where you downloaded your repo or you want to find an example
of a file you have already done in the past. For instance, typing this
in the command line

#+BEGIN_EXAMPLE bash
find /home/thisisme -name "*.pl6" -print
#+END_EXAMPLE

will return all files with the extension =pl6=, which is the usual one
in Perl6, in your home directory, as long as your username is
=thisisme=; change it to your username to apply it to your particular
situation. 

=find= is, then, kind of like =ls= on steroids. =ls= will return the
files in your folder, or if you do =ls -alt= will return them sorted
by date, which is useful when you do not remember the last file you
were working with. It happens.

** =grep=

You do not remember in which particular file you used a name like
=foo=? =grep= to the rescue

#+BEGIN_EXAMPLE bash
grep foo *.pl6
#+END_EXAMPLE

will look for your =foo= in all files with the extension =c=.

** Creating and destroying things

=mkdir= creates directories, =mkdir -p this/is/a/deep/directory=
creates a /leaf/ directory and all the rest, and =touch= creates empty
files. 


* ב‎ - Secure connection
    :PROPERTIES:
    :UNNUMBERED: t
    :END:

The whole point of programming is working with remote computers. And
in fact it is almost impossible that you work nowadays without using
several remote computers, /cloud/ hosts as it were, to perform routine
tasks. You need to connect to them, and do so efficiently and also
securely. That is why /ssh/ was invented.


* Working with, in and around data
Eventually you will need to give things a name, if only to avoid
cutting, pasting and recomputing stuff every time you need
it. /Variables/ store results and help you express, in a compact way,
complicated formulae. 
* ζ - Understand errors
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
Shit eventually happens. But when it does, you must be ready to unshit
everything. 

* ג‎ - Markdown for documentation 
    :PROPERTIES:
    :UNNUMBERED: t
    :END:

Every project should have a =README.md= that explains what it is
about, for everyone else if it is public, for our future self if it is
not. That =README.md= you have already created is written using
Markdown, a simplified method that adds marks to plain text to denote
its role in the document: its importance, if they are headers, and
even if they represent a hyperlink or the inclusion of an image. 

* Stand in the shoulders: /modules/ and using whatever is available
If there is a single motto you should follow when programming, is this
one: /Don't reinvent the wheel/. Before sitting down to do something,
check out if it has been already done. In mature languages like Perl,
the answer is most probably Yes. In some otheres, like this Perl 6 we
are dealing with, your mileage may vary. 
* η - Web weaving
   :PROPERTIES:
   :UNNUMBERED: t
    :END:
  
Whatever you do nowadays in computing, you will have to end up
presenting something somewhere, and that somewhere will most probably
be the web nowadays. So it does not harm, and it will benefit greatly,
to learn from now what the web is all about and how we can extract
information from it, use it to interact with people and publish our
data so that anyone in the whole wide world can see it. 
* ד‎ - Getting help
   :PROPERTIES:
   :UNNUMBERED: t
    :END:
No matter how good you are, or how easy the learning curve is, you
might eventually get stuck, because you do not find your way in a maze
of documents, you do not really know what you are looking for so that
you cannot tell Google precisely what you want, or maybe you ended up
in an alley nobody has ever been before. You cry for help, and a
language is only as good as the facilities that there are for helping
people in your predicament. Fortunately, Perl 6 is very good at that. 
* Building up: /scripts/ and /programs/
Doodling with the REPL is fun, but eventually you will need to profit:
the program has to be stored and maybe shipped somewhere. Architecting
a script needs to put your computational thinking skills to work. 
* θ - Pack all your troubles in a container
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
  
Applications run nowadays in all kind of places, so eventually someone
found a way to put all the stuff you need to run them in a single
tupperware container and ship it anywhere you need them, in the same
way as you pack your potato omelette in a tupper and carry it to grab
a byte in a picnic or during your train trip to Poughkeepsie, as you
are wont to do. Same goes for programs. Create it, pack it, take it
anywhere: the cloud, your other computer, anywhere you please. And if
you add another tupper with mandarines and yet another with a few
cupcakes, you have got your whole snack-a-lot ready to take anywhere.

Applications nowadays are composed of the equivalent of a three or
even more course meal. They have several courses plus snacks and even
a doggie bag to pack leftovers and a plastic bag for organic
trash. You can carry them in several places on you and your clothes,
but it is much better to just pack containers for everything and lay
them out on the table when you are ready to eat. In the case of
applications, they can be data processing units, data storing units,
data fooing and data baring units. Does not really matter what they
are, but the thing it that /containerization/ makes easy the creation
of a whole suite that can be stored and shipped anywhere. 

* г - Always play it safe
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
 
As long as you have created a program that is out there on the
Internet, and you need to take care of sending it somewhere, in a
Docker container or some other way, you need to /play it safe/. A
cloud container or virtual machine instance is just a resource for
crackers and fraudsters which will use all means possible to get hold
of it and hold it hostage for ransom or use it for bitmining,
launching distributed denial of service attacks, or as a cache for
stolen data. Fortunately, cloud and hosting providers usually detect
and deactivate them as soon as they find out, but you might incur in
huge bills or maybe huge annoyances while you work out with customer
service to have that bill erased.

That is why, as soon as you start to write your programs, you need to
play it safe. 
* Interacting with the user
Programs are created to be used. Many of them will be used by just
you. But some of them will be out there. You have to build them for an
indeal user, and that ideal user is a 90-year old FSB agent that is on
one hand not familiar with modern technology and that on the other
hand is familiar enough to try and break and enter in your program to
steal your family secrets. User interfaces have to be easy on the
user, but also secure. Never forget that. 
* ι - Testing for the win
   :PROPERTIES:
   :UNNUMBERED: t
   :END:
  
/If it is not tested, it is broken/ is something that you should learn
as soon as you start to crank out code. It actually means /If it is
not *automatically* tested, it is broken/, that is, it is not enough
that you give it two or maybe one input, and declare yourself
satisfied with it. No, son, that is not testing and you know it. 

* Д - Find the bug
   :PROPERTIES:
   :UNNUMBERED: t
   :END:
  
Testing reduces the need to find errors, but eventually some non-tested feature or a combination of things will make your program behave unexpectedly. No worries. /Debugging/ is the way to go. 

* Regular expressions
Machine learning is all about understanding text. That text does not
come in a shape you can easily process it. Regular expressions help
you deal with text that is not totally structured, but that has some
regularities in it. 
* κ - What you need to know about the cloud
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

The /cloud/ is where you run your programs nowadays. That is all you
need to know.

Not really. But almost.

* Deploying to the cloud
You have probably been told, by myself in the previous chapter, that
the cloud is where you run your program. But it is not going to go,
all by itself, to a cumulonimbus out there. You have to physically
take it, and that is what is called /deploying/. 
* λ - The world is my platform
   :PROPERTIES:
   :UNNUMBERED: t
   :END:
When creating a program, you can literally get the world to process part of your stuff, or obtain data from the same world. /Application programming interfaces/ make accessible, over the Internet, functions that would be annoying or simply impossible to have on your own computer. 
* Analyzing data
