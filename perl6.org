#+latex_compiler: xelatex
#+latex_header: \usepackage{libertine}
#+latex_header: \usepackage{unicode-math}
#+latex_header: \setmonofont{DejaVu Sans Mono}

* Perl 6, the musical

** ℵ - Principles

*** Learning should be fun and engaging: learn by doing.
*** You are the master of your learning process, and tools, and outcome. 
*** Learning never stops.
*** Learning is a two-way process. There is no professor, no student: learning happens ideally in a community. 

** α - Motivation

*** Teaching programming to (almost) non-programmers.
*** Contemplate the possibilities of Perl 6 as a beginner's language.
*** Show the beauty and craft of programming.
*** Use project-based learning throughout and flipped-learning techniques.

** 0 - Design thinking

Source https://dschool.stanford.edu/sandbox/groups/designresources/wiki/36873/attachments/74b3d/ModeGuideBOOTCAMP2010L.pdf?sessionID=e62aa8294d323f1b1540d3ee21e961cf7d1bce38

*** Empathization

Find users, find out about them, care about them, know their stories. Maybe you are the user, maybe it's someone close to you.

*** Definition

Define the challenge, what you want to do, express the problem. This
phase can be merged with the next one, since it is difficult to define
the problem without recourse about how you are going to solve the
problem itself. 

*** Ideate

Try to find out the solution to the problems your users have. 


In this phase you are supposed to produce ideas to solve the
problem. There will be no restriction other than whatever is required
by your target. You might want to create problems that imply certain
devices and not others, or solutions that cost no more than a certain
amount of money. 

*** Prototype

We will transition to actually doing something, incrementally. And
this is a phase, together with the following one, that is actually in
the engineering realm, so we are in familiar ground here. 

*** Test

If you are the user yourself, try it out. See if it is useful as
intended. Actually, test-driven design dictates that you cannot
actually prototype without testing in advance. So testing and
prototyping go hand in hand. 

** 1 - The tools 

This part will not be leading away from the design thinking mindset,
but actually will be getting into the last phases of it. Whatever idea
you had in mind will have to be kept stashed to go back to it whenever
you need it. In fact, we are entering the phase called /prototyping/,
or seen in another way, you are trying to solve a problem for a target
audience, yourself, by choosing the right tools. 

In this phase you will find that there's no perfect tool for doing
everything.

=Although the combination Linux + Emacs comes pretty close= 

Let's start with the operating system. That would be Linux. Whew, that
was short.

*** Shells 

Then, the command line interpreter, also called /shell/. This might seem like a given, but
in fact different command line interpreters have different
capabilities. In fact, even the [[https://www.gnu.org/software/bash/][humble bash]] has
interesting capabilities you can use. Main thing you want to tap is
the possibility of displaying interesting information in the command
line, such as the directory you are working on or, later on, the
branch of the repository you are in. And, in that sense, 
there are quite a few choices here, but the main
thing about them is the possibility of /theming/ them, that is, making
a configuration that allows, mostly, find the information we mention
above by just selecting a /theme/. In that sense [[http://zsh.sourceforge.net/][zsh]] and [[https://fishshell.com/][fish]] are very
strong contenders. Install them the usual way, and then select a theme
that goes easily with your programming habits;
[[https://github.com/robbyrussell/oh-my-zsh][Oh My Zsh]] or [[https://github.com/Bash-it/bash-it][bash-it]] are good places to start. 

Play a bit with the themes or options until you find one with all the
colors you want. And then come back here for the...

*** Editors. 

The choice of an editor goes beyond mere utility to become an
indentity, a side to stand when the flame war starts. As above, the
motto is always /suit yourself/, but since we are in the realm of
Perl6, I would propose [[http://atom.io][Atom]] as the editor to use. It is a modern
editor, it has got a good and evolving support for Perl 6, and it is
free software.

Not that the traditional Emacs and Vi/Vim are not good choices too. At
least Emacs, but Atom is easier to use and is improving in speed and
support by the minute. Besides, it has got everything it takes for
professional editor: syntax highlighting, being able to do some checks
from the editor itself, and allow running and debugging. It has got
all that, so that will be it. 

** 2 - The expressions

The first thing you need to know about a language, any language, is
how to compute things. Compute in the more general sense: combine
things to give other things. This, in general, is called expression,
which, also in general, is a bunch of symbols linked by *operators*. 

Generally, modern computer languages are able to work with many
different kind of symbols, and Perl6 is no exception. Let's start with
that.

*** REPLs and how to use them as glorified calculators

A
[[https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop][REPL]]
is a Read-Eval-Print loop. it is a program included with most
interpreted languages, that presents a command-line prompt and into
which you can type expressions, and, later on, full statements. But,
for the time being, let's type


#+BEGIN_EXAMPLE bash
perl6
#+END_EXAMPLE

And we will be into a perl6 REPL into which you can type Perl6 stuff.

Let's try the simplest thing:


#+BEGIN_EXAMPLE perl6
To exit type 'exit' or '^D'
> sin(π/2)
#+END_EXAMPLE

You will have to find a way to type that π, by copy/pasting it from
some website or google or right this. It will return the sine of π/2,
which, as you know, is 1. 

And this is cool, because only some languages are able to handle this
kind of expressions, and, even more, to use it correctly in math. But
you can do even more:


#+BEGIN_EXAMPLE perl6
sin(π/2) +1
#+END_EXAMPLE

You can do that by copying/pasting, or else install =Linenoise=, a
command line that allows you to go back to previous command by typing
arrow-up. Do it with


#+BEGIN_EXAMPLE bash
zef install Linenoise
#+END_EXAMPLE

You can use the usual arithmetic operators =+,-,*,/= but Perl6 adds
two typographic operators, ÷ and × (these ones are produced in the
Spanish keyboard with May+AltGr+ comma or period), like


#+BEGIN_EXAMPLE perl6
sin(π/3) × sin(π/3) + cos(π/3) × cos(π/3)
#+END_EXAMPLE

Or, even better


#+BEGIN_EXAMPLE perl6
sin(π/3)² + cos(π/3)²
#+END_EXAMPLE

One of the objectives of Perl6 is to use the whole range of characters
that Unicode, if not modern keyboards, offer. This simplifies
expressions and makes them more readable. 

*** Now that we mention Unicode

Unicode is the way to express all alphabets in the world, and then
some things that are not really alphabets. It uses up to around sixty
thousand symbols, and allows us to write, using modern operating
systems, editors and languages, anything that would have to be
expressed in living or dead languages, and even some
emoticons. Unicode is evolving constantly, and for the people means
that they will be able to use characters that are usual in their own
language, and also some usual in mathematical expressions. 

Since not all languages, editors, operating systems or even keyboards
are *modern* in that sense, some impedance should be expected. But
Perl 6 will not get in your way, allowing you to use them just they
way they should, so if you want to raise something to the second power
you will not have to, although you can, write x**2 but simply x².

*** It's not only numbers

All the expressions written above are numbers. 


#+BEGIN_EXAMPLE perl6
(sin(π/3)² + cos(π/3)²).WHAT
#+END_EXAMPLE

is going to return =(Num)=, indicating that it is simply a Number,
actually a real number. You
can add or substract numbers that way, but you cannot do 


#+BEGIN_EXAMPLE perl6
sin(π/3)² + cos(π/3)² + " is 1"
#+END_EXAMPLE

will yield this error
#+CAPTION: Errorred expression in the REPL
#+NAME:   fig:chap2-expression
[[./img/expression-error.png]]

That shows that there are more types of data you can use and work with
from the REPL. In fact, there are a lot. In general, you cannot mix
and match and, also in general, every one has got its own operators
you can work with. You can mix fractions with integer numbers, for
instance: 

#+BEGIN_EXAMPLE perl6
 ⅓+4/3
#+END_EXAMPLE

And 

#+BEGIN_EXAMPLE perl6
(⅓+4/3).WHAT
#+END_EXAMPLE

will return =(Rat)=, a Rational, same as =⅓+4=. In fact, most
[[http://blogs.perl.org/users/ovid/2015/02/a-little-thing-to-love-about-perl-6-and-cobol.html][floating point numbers in Perl 6 will be represented as rational]],
unless we explicitly tell the interpreter to deal with them as
floating point, that is real, numbers, which, BTW, cannot be something
else that fractional numbers since they use a finite representation in
computers. Mostly.

However, in some cases you can try and mix different things using an
operator. Operator "~" concatenates stuff, that is, joins things that
look like words and letters, for instance

#+BEGIN_EXAMPLE perl6
6 ~ "6"
#+END_EXAMPLE

will return =66=, and anything you put there will be concatenated. =~=
is an operator that is not picky about what it has got in both ends. 

*** And there's more

Numbers and words are simple things. But you can string them together
in something more complex. You can have sets of them, or lists of
them, or combine them as sets of lists of sets of whatever. Perl 6 is
great because you do not need to make all things in a complex
structure be of the same type. You can create a list with the less than
and more than sign, this way:

#+BEGIN_EXAMPLE perl6
<a b 7 ⅓ π²>
#+END_EXAMPLE

And with lists, you can do things like sorting:

#+BEGIN_EXAMPLE perl6
sort <a b 7 ⅓ π²>
#+END_EXAMPLE

or combine lists to create a new one using the =X= operator, called
*cross product* 

#+BEGIN_EXAMPLE perl6
<a b 7 ⅓ π²> X < → ← >
#+END_EXAMPLE

for long lists, you might want to use only the first and last term 

#+BEGIN_EXAMPLE perl6
1...222
#+END_EXAMPLE

via the *yada, yada, yada* operator, or, even better,

#+BEGIN_EXAMPLE perl6
1 … 333
#+END_EXAMPLE

Not so easy or straightforward to combine lists. However, [[http://stackoverflow.com/questions/34567902/perl-6-list-concatenation-without-slip][not
impossible]]:

#+BEGIN_EXAMPLE perl6
<a b 7 ⅓ π²> , < → ← >
#+END_EXAMPLE

is going to create a new list with two elements, each one of which is
a list. You can *flatten* it:

#+BEGIN_EXAMPLE perl6
flat <a b 7 ⅓ π²> , < → ← >
#+END_EXAMPLE

But the coolest thing with lists is the stuff you can do to all of
them at the same time:

#+BEGIN_EXAMPLE perl6
[+] 1 … 333
#+END_EXAMPLE

will add everything together. Any operator you put inside brackets
will be applied to all in turn. Try =[*] 1 … 333=, for instance.
